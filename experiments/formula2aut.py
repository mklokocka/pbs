import argparse
import os
import subprocess
import sys

class AutomataGenerator:
    '''Class for generating random automata.

    The class is used to generate random automata identified with a LTL-like
    formula for using ltlcross for comparing tools on random automata instead
    of LTL formulas.

    Attributes:
        output_dir (str, optional): Directory to output automata to (default to
            current directory).
    '''

    def __init__(self, output_dir=''):
        self.output_dir = output_dir

    def _create_args(self, location, ap_count, min_states, max_states,
                     generalized, deterministic):
        '''Format arguments for calling randaut.

        Note that we request infinite number of automata from randaut. This is
        so that we can use autfilt to filter out useless automata.

        Args:
            Check `generate`.

        Return:
            list of str: List of arguments for randaut.
        '''
        args = [f'-A..{generalized}', f'-Q{min_states}..{max_states}',
                f'-n -1', f'{ap_count}', '--name=%L']

        if deterministic:
            args.append('-D')

        return args

    def generate(self, count, formula_prefix='aut', formula_file=None, ap_count=2, min_states=2,
                 max_states=7, generalized=1, deterministic=False, complements=False):
        '''Generate random automata.

        Generates random automata with the given paramaters using the Spot
        tool randaut and saves them in `output_dir`. Each automaton has an
        identifier made from a given prefix `formula_prefix` and a number.

        A map from identifying formula to the automaton file is then created
        and printed to stdout or into a file `formula_file`.

        Args:
            count (int): Number of automata to generate.
            formula_prefix (str, optional): Prefix to use for the LTL-like
                formulas encoding each automaton (defaults to `aut`).
            formula_file (str, optional): File for writing the LTL-like formulas
                identifying each automaton to (if given).
            ap_count (int, optional): Number of atomic propositions to use (
                defaults to 2).
            min_states (int, optional): Minimal number of states (defaults to 2).
            max_states (int, optional): Maximal number of states (defaults to 7).
            generalized (int, optional): Maximal number of used acceptance sets
                (defaults to 1).
            deterministic (bool, optional): Generate deterministic automata (
                default to False).
            complements (bool, optional): Whether to generate complements of the
                generated automatons (used for checks, defaults to False).
        '''
        location = f'{self.output_dir}/{formula_prefix}'

        randaut_args = self._create_args(location, ap_count, min_states, max_states,
                                    generalized, deterministic)
        autfilt_args = ['--small', '--is-empty', '-v', '-u', f'-n {count}', f'--output={location}%M.hoa']
        
        print('running the following command:')
        cmd = ['randaut'] + randaut_args + ['|'] + ['autfilt'] + autfilt_args
        print(' '.join(cmd))

        # Run randaut | autfilt.
        randaut = subprocess.Popen(['randaut'] + randaut_args, stdout=subprocess.PIPE)
        autfilt = subprocess.check_output(['autfilt'] + autfilt_args, stdin=randaut.stdout)
        randaut.stdout.close()

        # Get complements if necessary.
        if complements:
            print('generating complements')
            for aut in os.listdir(self.output_dir):
                automaton = f'{self.output_dir}/{aut}'

                # We do not really care for the type, only used in checks.
                complement_args = ['--complement', '--small', '--tgba',
                                   f'--file={automaton}', f'--output={self.output_dir}/!{aut}']

                subprocess.call(['autfilt'] + complement_args, stderr=subprocess.STDOUT)

        # Generate the formula file.
        if formula_file:
            print('generating formula file')
            with open(formula_file, 'w') as f:
                # We have to filter out complements, ltlcross handles this itself.
                for aut in os.listdir(self.output_dir):
                    if aut[0] != '!':
                        print(f'{aut[:-4]}', file=f)

class AutomataParser:
    '''Class for reading automata generated by `AutomataGenerator`.

    The class is used to parse LTL-like identified automata by using the
    identifier.

    Attributes:
        input_dir (str, optional): Directory to read automata from (default to
            current directory).

    '''

    def __init__(self, input_dir):
        self.input_dir = input_dir

    def _read_aut(self, aut_file):
        """Read an automaton from file.

        Opens a file with an automata and print the output to stdout.
        """
        try:
            return open(aut_file,'r').read()
        except FileNotFoundError:
            raise ValueError(f'The given formula does not match any automaton.')

    def formula2aut(self, formula):
        # Check if complement is generated by ltlcross (parentheses), remove them
        # if necessary.
        if formula[:2] == '!(':
            formula = f'!{formula[2:-1]}'

        return self._read_aut(f'{self.input_dir}/{formula}.hoa')

if __name__ == "__main__":
    parser = argparse.ArgumentParser \
      (description='Generate random automata or read such automata by their LTL-like id.',
           allow_abbrev=True)
    # Main settings.
    parser.add_argument('-d', '--directory', type=str,
                        help='working directory for generated automata (automata)',
                        default='automata')
    parser.add_argument('-g', '--generate', action='store_true',
                        help='switch to generation of random automata (false)')
    # For parsing.
    parser.add_argument('formula', type=str, nargs='*',
                        help='formula to parse to an automaton')
    # For generation.
    parser.add_argument('-p', '--prefix', type=str,
                        help='prefix for the LTL-like formulas (aut)',
                        default='aut')
    parser.add_argument('-f', '--file', type=str,
                        help='file for ids (formulas) of generated automata',
                        default='')
    parser.add_argument('-n', '--count', type=int,
                        help='generate n automata (100)',
                        default=100)
    parser.add_argument('-ap', '--ap_count', type=int,
                        help='generate automata with the given number of '
                        'atomic propositions (2)',
                        default=2)
    parser.add_argument('-q', '--states', type=int, nargs=2,
                        help='generate automata with the number of states between'
                        ' the two values (2 7)',
                        default=[2, 7])
    parser.add_argument('-a', '--acceptance', type=int,
                        help='generate automata with the number of acc. sets between'
                        ' 1 and this value (1)',
                        default=1)
    parser.add_argument('-det', '--deterministic', action='store_true',
                        help='generate only deterministic automata')
    parser.add_argument('-c', '--complements', action='store_true',
                        help='also generate complements')

    args = parser.parse_args()

    if not args.generate:
        if not args.formula:
            raise ValueError('Missing input formula.')
        if len(args.formula) > 1:
            raise ValueError('Require exactly one formula.')
        parser = AutomataParser(args.directory)
        print(parser.formula2aut(args.formula[0]))
    else:
        generator = AutomataGenerator(args.directory)
        generator.generate(args.count, args.prefix, args.file, args.ap_count,
                           args.states[0], args.states[1], args.acceptance,
                           args.deterministic, args.complements)
